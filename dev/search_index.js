var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Artificially-centered-hit-and-run-sampling","page":"Reference","title":"Artificially centered hit-and-run sampling","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CuFluxSampler, CuFluxSampler.ACHR]\nPages = [\"ACHR.jl\"]","category":"page"},{"location":"reference/#CuFluxSampler.ACHR.sample-Tuple{COBREXA.MetabolicModel, AbstractMatrix}","page":"Reference","title":"CuFluxSampler.ACHR.sample","text":"sample(\n    m::COBREXA.MetabolicModel,\n    start::AbstractMatrix;\n    iters,\n    bound_stoichiometry,\n    check_stoichiometry,\n    direction_noise_max,\n    epsilon,\n    seed\n)\n\n\nA traditional artificially-centered hit-and-run algorithm that starts with start points.\n\nRefer to the documentation in module AffineHR for the meaning of arguments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Affine-hit-and-run-sampling","page":"Reference","title":"Affine hit-and-run sampling","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CuFluxSampler, CuFluxSampler.AffineHR]\nPages = [\"AffineHR.jl\"]","category":"page"},{"location":"reference/#CuFluxSampler.AffineHR.sample-Tuple{COBREXA.MetabolicModel, AbstractMatrix}","page":"Reference","title":"CuFluxSampler.AffineHR.sample","text":"sample(\n    m::COBREXA.MetabolicModel,\n    start::AbstractMatrix;\n    iters,\n    bound_stoichiometry,\n    check_stoichiometry,\n    direction_noise_max,\n    epsilon,\n    seed,\n    mix_points,\n    mix_mtx,\n    permute_mtx\n)\n\n\nUse the affine-combination hit-and-run algorithm to generate a sample of the feasible area of m from the set of start points supplied as columns in a matrix.\n\nThe run directions are generated from random affine combination of mix_points points (by default 3); matrices mix_mtx and permute_mtx give fine control about the mixing in the process. Preferably, this matrix is very sparse.\n\ncheck_stoichiometry allows to turn on/off the filtering of generated points based on whether they are close to the steady state (with tolerance epsilon). bound_stoichiometry additionally computes run bounds based on the steady-state region, and uses it to generate better runs. This is useful in combination with direction_noise_max which may add a small noise to the generated run directions, allowing the sampler to discover new directions (potentially not obvious from warmup in start), but easily explodes without limiting the directions.\n\nAdditional bounds on run ranges are taken from model coupling constraints, if present.\n\nIf you are generating a sample of the optimal model solution, it is expected that the optimum bound is already present in m.\n\nReturns a matrix of the same size as start.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Full-linear-combination-affine-hit-and-run-sampling-(internal)","page":"Reference","title":"Full-linear-combination affine hit-and-run sampling (internal)","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CuFluxSampler, CuFluxSampler.FullAffineHR]\nPages = [\"FullAffineHR.jl\"]","category":"page"},{"location":"reference/#CuFluxSampler.FullAffineHR.sample-Tuple{COBREXA.MetabolicModel, AbstractMatrix}","page":"Reference","title":"CuFluxSampler.FullAffineHR.sample","text":"sample(\n    m::COBREXA.MetabolicModel,\n    warmup::AbstractMatrix;\n    npts,\n    iters,\n    bound_stoichiometry,\n    check_stoichiometry,\n    direction_noise_max,\n    epsilon,\n    seed\n)\n\n\nUse the full-affine-combination hit-and-run algorithm to generate a sample of the feasible area of m from the warmup points supplied as columns in a matrix.  If you are generating a sample of the optimal solution, it is expected that the optimum bound is already present in m.\n\nReturns a matrix of npts samples organized in columns.\n\nThis algorithm is mostly a toy for comparing the performance. It works, but do not use it in production.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Internal-functions","page":"Reference","title":"Internal functions","text":"","category":"section"},{"location":"reference/#TEA-based-RNG","page":"Reference","title":"TEA-based RNG","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CuFluxSampler, CuFluxSampler.TeaRNG]\nPages = [\"TeaRNG.jl\"]","category":"page"},{"location":"reference/#CuFluxSampler.TeaRNG","page":"Reference","title":"CuFluxSampler.TeaRNG","text":"Fast stateless random number generator for GPUs based on TEA cipher.\n\n\n\n\n\n","category":"module"},{"location":"reference/#CuFluxSampler.TeaRNG.device_fill_rand!-Tuple{Any, UInt32}","page":"Reference","title":"CuFluxSampler.TeaRNG.device_fill_rand!","text":"device_fill_rand!(arr, seed::UInt32)\n\n\nCUDA.jl grid-stride kernel that fills the array with random numbers generated by tea_random. seed is used as the stream ID, global thread index in grid is used as the sequence number.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CuFluxSampler.TeaRNG.tea_random-Tuple{UInt32, UInt32}","page":"Reference","title":"CuFluxSampler.TeaRNG.tea_random","text":"tea_random(stream::UInt32, seq::UInt32) -> UInt32\n\n\nUse TEA cipher algorithm to reproducibly generate a seq-th random number from the stream-th random stream.\n\n\n\n\n\n","category":"method"},{"location":"#CuFluxSampler.jl","page":"README","title":"CuFluxSampler.jl","text":"","category":"section"},{"location":"","page":"README","title":"README","text":"Modules = [CuFluxSampler]\nPages = [\"CuFluxSampler.jl\"]","category":"page"},{"location":"#CuFluxSampler.CuFluxSampler","page":"README","title":"CuFluxSampler.CuFluxSampler","text":"CuFluxSampler.jl\n\nDocumentation\n(Image: stable documentation) (Image: dev documentation)\n\nFlux samplers for COBREXA.jl, accelerated on GPUs via CUDA.jl.\n\nThe repository contents is work in progress, but the existing code should generally work. The implemented samplers currently include:\n\nAffine-combination-directed Hit&Run (module CuFluxSampler.AffineHR)\n\nRunning the package code and tests requires a CUDA-capable GPU.\n\nAcknowledgements\n\nCuFluxSampler.jl was developed at the Luxembourg Centre for Systems Biomedicine of the University of Luxembourg (uni.lu/lcsb). The development was supported by European Union's Horizon 2020 Programme under PerMedCoE project (permedcoe.eu), agreement no. 951773.\n\n<img src=\"docs/src/assets/unilu.svg\" alt=\"Uni.lu logo\" height=\"64px\">   <img src=\"docs/src/assets/lcsb.svg\" alt=\"LCSB logo\" height=\"64px\">   <img src=\"docs/src/assets/permedcoe.svg\" alt=\"PerMedCoE logo\" height=\"64px\">\n\n\n\n\n\n","category":"module"}]
}
